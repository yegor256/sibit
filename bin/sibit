#!/usr/bin/env ruby
# frozen_string_literal: true

# SPDX-FileCopyrightText: Copyright (c) 2019-2026 Yegor Bugayenko
# SPDX-License-Identifier: MIT

$stdout.sync = true

require 'backtrace'
require 'ellipsized'
require 'loog'
require 'retriable_proxy'
require 'thor'
require_relative '../lib/sibit'
require_relative '../lib/sibit/http'
require_relative '../lib/sibit/httpproxy'
require_relative '../lib/sibit/bitcoinchain'
require_relative '../lib/sibit/blockchain'
require_relative '../lib/sibit/blockchair'
require_relative '../lib/sibit/btc'
require_relative '../lib/sibit/cex'
require_relative '../lib/sibit/dry'
require_relative '../lib/sibit/fake'
require_relative '../lib/sibit/firstof'
require_relative '../lib/sibit/version'

# Command-line interface for Sibit.
# Provides commands to interact with the Bitcoin network.
class Bin < Thor
  class_option :proxy, type: :string, desc: 'HTTPS proxy for all requests, e.g. "localhost:3128"'
  class_option :attempts, type: :numeric, default: 1,
                          desc: 'How many times should we try before failing'
  class_option :dry, type: :boolean, default: false,
                     desc: "Don't send a real payment, run in a read-only mode"
  class_option :verbose, type: :boolean, default: false, desc: 'Print all possible debug messages'
  class_option :api, type: :array, default: %w[blockchain btc bitcoinchain blockchair cex],
                     desc: 'Ordered List of APIs to use, e.g. "blockchain,btc,bitcoinchain"'

  def self.exit_on_failure?
    true
  end

  desc 'price', 'Get current price of BTC in USD'
  def price
    log.info(client.price)
  end

  desc 'fees', 'Get currently recommended transaction fees'
  def fees
    sibit = client
    fees = sibit.fees
    text = %i[S M L XL].map do |m|
      sat = fees[m] * 250
      usd = sat * sibit.price / 100_000_000
      "#{m}: #{sat}sat / $#{format('%<usd>.02f', usd: usd)}"
    end.join("\n")
    log.info(text)
  end

  desc 'latest', 'Get hash of the latest block'
  def latest
    log.info(client.latest)
  end

  desc 'generate', 'Generate a new private key'
  def generate
    log.info(client.generate)
  end

  desc 'create KEY', 'Create a public Bitcoin address from the private key'
  def create(key)
    log.debug("Private key provided: #{key.ellipsized(8).inspect}")
    log.info(client.create(key))
  end

  desc 'balance ADDRESS', 'Check the balance of the Bitcoin address'
  def balance(address)
    log.info(client.balance(address))
  end

  desc 'pay AMOUNT FEE SOURCES TARGET CHANGE', 'Send a new Bitcoin transaction'
  option :skip_utxo, type: :array, default: [],
                     desc: 'List of UTXO that must be skipped while paying'
  def pay(amount, fee, sources, target, change)
    amount = amount.to_i if /^[0-9]+$/.match?(amount)
    fee = fee.to_i if /^[0-9]+$/.match?(fee)
    log.info(
      client.pay(
        amount, fee,
        sources.split(','),
        target, change,
        skip_utxo: options[:skip_utxo]
      )
    )
  end

  desc 'version', 'Print program version'
  def version
    log.info(Sibit::VERSION)
  end

  private

  def log
    @log ||= options[:verbose] ? Loog::VERBOSE : Loog::REGULAR
  end

  def client
    http = options[:proxy] ? Sibit::HttpProxy.new(options[:proxy]) : Sibit::Http.new
    apis = options[:api].flat_map { |a| a.split(',') }.map(&:downcase).map do |a|
      case a
      when 'blockchain'
        Sibit::Blockchain.new(http: http, log: log)
      when 'btc'
        Sibit::Btc.new(http: http, log: log)
      when 'bitcoinchain'
        Sibit::Bitcoinchain.new(http: http, log: log)
      when 'blockchair'
        Sibit::Blockchair.new(http: http, log: log)
      when 'cex'
        Sibit::Cex.new(http: http, log: log)
      when 'fake'
        Sibit::Fake.new
      else
        raise Sibit::Error, "Unknown API \"#{a}\""
      end
    end
    api = Sibit::FirstOf.new(apis, log: log, verbose: true)
    api = Sibit::Dry.new(api, log: log) if options[:dry]
    api = RetriableProxy.for_object(api, on: Sibit::Error) if options[:attempts] > 1
    Sibit.new(log: log, api: api)
  end
end

begin
  Bin.start(ARGV)
rescue StandardError => e
  log = ARGV.include?('--verbose') ? Loog::VERBOSE : Loog::REGULAR
  if ARGV.include?('--verbose')
    log.error(Backtrace.new(e))
  else
    log.error(e.message)
  end
  exit(255)
end
